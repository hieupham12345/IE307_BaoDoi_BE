import { NO_PROVIDER, SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, reuseSpecialProps, parseName, name, autoName, inject, useInject, mergeInject, autoInject, alsoInject, type, extra, singleton, initializer, constant, service, autoService, provider, autoProvider, wrapInitializer, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties } from './util.js';
import initFatalError, { FATAL_ERROR } from './fatalError.js';
import initDispose, { DISPOSE } from './dispose.js';
import initInitializerBuilder from './build.js';
import type { ServiceName, Service, Disposer, FatalErrorPromise, Provider, Dependencies, DependencyDeclaration, ExtraInformations, ParsedDependencyDeclaration, ConstantProperties, ConstantInitializer, ProviderInitializerBuilder, ProviderProperties, ProviderInitializer, ProviderInputProperties, ServiceInitializerBuilder, ServiceProperties, ServiceInitializer, ServiceInputProperties, AsyncInitializerBuilder, AsyncInitializer, PartialAsyncInitializer, Initializer, ServiceInitializerWrapper, ProviderInitializerWrapper, HandlerFunction, Parameters } from './util.js';
import type { BuildInitializer } from './build.js';
import type { FatalErrorService } from './fatalError.js';
export { initFatalError, initDispose };
export type { ServiceName, Service, Disposer, FatalErrorPromise, Provider, Dependencies, DependencyDeclaration, ExtraInformations, ParsedDependencyDeclaration, ConstantProperties, ConstantInitializer, ProviderInitializerBuilder, ProviderProperties, ProviderInitializer, ProviderInputProperties, ServiceInitializerBuilder, ServiceProperties, ServiceInitializer, ServiceInputProperties, AsyncInitializerBuilder, AsyncInitializer, PartialAsyncInitializer, Initializer, ServiceInitializerWrapper, ProviderInitializerWrapper, HandlerFunction, Parameters, BuildInitializer, FatalErrorService, };
export declare const RUN_DEPENDENT_NAME = "__run__";
export declare const SYSTEM_DEPENDENT_NAME = "__system__";
export declare const AUTOLOAD_DEPENDENT_NAME = "__autoloader__";
export declare const INJECTOR_DEPENDENT_NAME = "__injector__";
export { NO_PROVIDER };
export type KnifecycleOptions = {
    sequential?: boolean;
};
export interface Injector<T extends Record<string, unknown>> {
    (dependencies: DependencyDeclaration[]): Promise<T>;
}
export interface Autoloader<T extends Initializer<unknown, Record<string, unknown>>> {
    (name: DependencyDeclaration): Promise<{
        initializer: T;
        path: string;
    }>;
}
export type SiloIndex = string;
export type BaseInitializerStateDescriptor<S, D extends Dependencies> = {
    dependents: {
        silo?: SiloIndex;
        name: ServiceName;
        optional: boolean;
    }[];
    initializerLoadPromise?: Promise<Initializer<S, D>>;
    initializer?: Initializer<S, D>;
    autoloaded: boolean;
};
export type SiloedInitializerStateDescriptor<S, D extends Dependencies> = BaseInitializerStateDescriptor<S, D> & {
    silosInstances: Record<SiloIndex, {
        dependency?: ServiceName;
        provider?: NonNullable<Provider<S> | typeof NO_PROVIDER>;
        providerLoadPromise?: Promise<void>;
        instanceDisposePromise?: Promise<S>;
    }>;
};
export type SingletonInitializerStateDescriptor<S, D extends Dependencies> = BaseInitializerStateDescriptor<S, D> & {
    singletonProvider?: NonNullable<Provider<S> | typeof NO_PROVIDER>;
    singletonProviderLoadPromise?: Promise<void>;
    disposer?: Disposer;
    fatalErrorPromise?: FatalErrorPromise;
};
export type AutoloadedInitializerStateDescriptor<S, D extends Dependencies> = BaseInitializerStateDescriptor<S, D> & {
    autoloaded: true;
};
export type InitializerStateDescriptor<S, D extends Dependencies> = SingletonInitializerStateDescriptor<S, D> | SiloedInitializerStateDescriptor<S, D> | AutoloadedInitializerStateDescriptor<S, D>;
export interface SiloContext {
    index: SiloIndex;
    loadingServices: ServiceName[];
    loadingSequences: ServiceName[][];
    _shutdownPromise?: Promise<void>;
}
export type InternalDependencies = {
    $dispose: Disposer;
    $autoload: Autoloader<Initializer<unknown, Record<string, unknown>>>;
    $injector: Injector<Record<string, unknown>>;
    $instance: Knifecycle;
    $siloContext: SiloContext;
    $fatalError: FatalErrorService;
};
export { DISPOSE, FATAL_ERROR };
export declare const AUTOLOAD = "$autoload";
export declare const INJECTOR = "$injector";
export declare const INSTANCE = "$instance";
export declare const SILO_CONTEXT = "$siloContext";
export declare const UNBUILDABLE_SERVICES: string[];
declare class Knifecycle {
    private _options;
    private _silosCounter;
    _silosContexts: Record<SiloIndex, SiloContext>;
    _initializersStates: Record<string, InitializerStateDescriptor<unknown, Dependencies>>;
    private _shutdownPromise?;
    /**
     * Create a new Knifecycle instance
     * @param {Object}  options
     * An object with options
     * @param {boolean} options.sequential
     * Allows to load dependencies sequentially (usefull for debugging)
     * @return {Knifecycle}
     * The Knifecycle instance
     * @example
     *
     * import Knifecycle from 'knifecycle'
     *
     * const $ = new Knifecycle();
     */
    constructor(options?: KnifecycleOptions);
    /**
     * Register an initializer
     * @param  {Function}   initializer
     * An initializer
     * @return {Knifecycle}
     * The Knifecycle instance (for chaining)
     */
    register<T extends Initializer<unknown, any>>(initializer: T): Knifecycle;
    _checkInitializerOverride(serviceName: ServiceName): void;
    _buildInitializerState(initializerState: InitializerStateDescriptor<any, any>, initializer: Initializer<unknown, any>): void;
    _checkInitializerDependencies(initializer: Initializer<any, any>): void;
    _lookupCircularDependencies(rootServiceName: ServiceName, dependencyDeclaration: DependencyDeclaration, declarationsStacks?: DependencyDeclaration[]): void;
    /**
     * Outputs a Mermaid compatible dependency graph of the declared services.
     * See [Mermaid docs](https://github.com/knsv/mermaid)
     * @param {Object} options
     * Options for generating the graph (destructured)
     * @param {Array<Object>} options.shapes
     * Various shapes to apply
     * @param {Array<Object>} options.styles
     * Various styles to apply
     * @param {Object} options.classes
     * A hash of various classes contents
     * @return {String}
     * Returns a string containing the Mermaid dependency graph
     * @example
     *
     * import Knifecycle, { inject, constant, service } from 'knifecycle';
     * import appInitializer from './app';
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.register(constant('OS', require('os')));
     * $.register(service('app', inject(['ENV', 'OS'], appInitializer)));
     * $.toMermaidGraph();
     *
     * // returns
     * graph TD
     *   app-->ENV
     *   app-->OS
     */
    toMermaidGraph({ shapes, styles, classes, }?: {
        shapes?: MermaidShapes;
        styles?: MermaidStyles;
        classes?: MermaidClasses;
    }): string;
    /**
     * Creates a new execution silo
     * @param  {String[]}   dependenciesDeclarations
     * Service name.
     * @return {Promise}
     * Service descriptor promise
     * @example
     *
     * import Knifecycle, { constant } from 'knifecycle'
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.run(['ENV'])
     * .then(({ ENV }) => {
     *  // Here goes your code
     * })
     */
    run<ID extends Record<string, unknown>>(dependenciesDeclarations: DependencyDeclaration[]): Promise<ID>;
    _getInitializer(serviceName: ServiceName): Initializer<unknown, Dependencies> | undefined;
    _getServiceProvider(siloContext: SiloContext, serviceName: ServiceName): Provider<unknown> | typeof NO_PROVIDER | undefined;
    _loadInitializerDependencies(siloContext: SiloContext, parentsNames: ServiceName[], dependenciesDeclarations: DependencyDeclaration[], additionalDeclarations: DependencyDeclaration[]): Promise<Dependencies>;
    _loadProvider(siloContext: SiloContext, serviceName: ServiceName, parentsNames: ServiceName[]): Promise<void>;
    _getAutoloader(siloContext: SiloContext, parentsNames: ServiceName[]): Promise<Autoloader<Initializer<unknown, Dependencies<unknown>>> | undefined>;
    _loadInitializer(siloContext: SiloContext, serviceName: ServiceName, parentsNames: ServiceName[]): Promise<void>;
    _resolveDependencies(siloContext: SiloContext, loadingServices: ServiceName[], parentsNames: ServiceName[]): Promise<void>;
    /**
     * Destroy the Knifecycle instance
     * @return {Promise}
     * Full destruction promise
     * @example
     *
     * import Knifecycle, { constant } from 'knifecycle'
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.run(['ENV'])
     * .then(({ ENV }) => {
     *    // Here goes your code
     *
     *    // Finally destroy the instance
     *    $.destroy()
     * })
     */
    destroy(): Promise<void>;
}
export { SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, parseName, Knifecycle, initializer, name, autoName, type, inject, useInject, mergeInject, autoInject, alsoInject, extra, singleton, reuseSpecialProps, wrapInitializer, constant, service, autoService, provider, autoProvider, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties, initInitializerBuilder, };
type MermaidShapes = {
    pattern: RegExp;
    template: string;
}[];
type MermaidStyles = {
    pattern: RegExp;
    className: string;
}[];
type MermaidClasses = {
    [name: string]: string;
};
